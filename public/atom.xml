<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>美好的一天</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhouyanbo.com/"/>
  <updated>2020-10-29T11:08:59.741Z</updated>
  <id>https://zhouyanbo.com/</id>
  
  <author>
    <name>zhouyb90</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>129. 求根到叶子节点数字之和</title>
    <link href="https://zhouyanbo.com/2020/10/29/leetcode129/"/>
    <id>https://zhouyanbo.com/2020/10/29/leetcode129/</id>
    <published>2020-10-29T10:40:46.000Z</published>
    <updated>2020-10-29T11:08:59.741Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode每日一题疑惑</p><p>今天的leetcode每日一题<a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. 求根到叶子节点数字之和</a></p><p>看完题以后想了种解法（比较繁琐，层序遍历，记录到根节点的所有数字，最后再求和），不要在意细节，看完题解发现自己写的太复杂了，此文不讨论算法，记录下其中的一个疑惑，希望有大佬给解答下。</p><p>先上代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumNumbers</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">numbers := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 遍历所有到叶子节点的路径，存到numbers中</span></span><br><span class="line">queue := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">values := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">values = <span class="built_in">append</span>(values, []<span class="keyword">int</span>&#123;root.Val&#125;)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">q := queue[<span class="number">0</span>]</span><br><span class="line">v := values[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line">values = values[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> q.Left == <span class="literal">nil</span> &amp;&amp; q.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> q.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, q.Left)</span><br><span class="line"><span class="comment">// tempV := make([]int, len(v))</span></span><br><span class="line"><span class="comment">// copy(tempV, v)</span></span><br><span class="line">values = <span class="built_in">append</span>(values, <span class="built_in">append</span>(v, q.Left.Val))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> q.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, q.Right)</span><br><span class="line"><span class="comment">// tempV := make([]int, len(v))</span></span><br><span class="line"><span class="comment">// copy(tempV, v)</span></span><br><span class="line">values = <span class="built_in">append</span>(values, <span class="built_in">append</span>(v, q.Right.Val))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, number := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(number); i++ &#123;</span><br><span class="line">sum = sum*<span class="number">10</span> + number[i]</span><br><span class="line">&#125;</span><br><span class="line">ans += sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给的用例通过了，于是提交，发现卡在这个用例上</p><p><img src="./images/leetcode129.png" alt></p><p>debug以后，发现在进行到其中某一步的时候values中第一个切片最后一个元素本来是9，后来变成5了，不明白咋回事</p><p>原来values [[8,3,9,9]]，append一个切片[8,3,9,5]以后应该是[[8,3,9,9], [8,3,9,5]]，可是变成了[[8,3,9,5], [8,3,9,5]]，导致结果出错，应该是切片的问题，不太明白，谁能解释一下其中的原因，为啥原有的数据会被改变，感谢大佬。</p><p>注释掉的是后来把切片copy了下，问题解决了，知道是切片问题，没想明白为啥。</p><p>提供下出错用例的树形结构供debug</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val <span class="keyword">int</span></span><br><span class="line">Left *TreeNode</span><br><span class="line">Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//      8</span></span><br><span class="line"><span class="comment">//     / \</span></span><br><span class="line"><span class="comment">//    3   5</span></span><br><span class="line"><span class="comment">//     \  </span></span><br><span class="line"><span class="comment">//      9 </span></span><br><span class="line"><span class="comment">//    /  \      </span></span><br><span class="line"><span class="comment">//    9    5     </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">node5 := &amp;TreeNode&#123;Val: <span class="number">5</span>&#125;</span><br><span class="line">node52 := &amp;TreeNode&#123;Val: <span class="number">5</span>&#125;</span><br><span class="line">node92 := &amp;TreeNode&#123;Val: <span class="number">9</span>&#125;</span><br><span class="line">node9 := &amp;TreeNode&#123;Val: <span class="number">9</span>, Left: node92, Right: node52&#125;</span><br><span class="line">node3 := &amp;TreeNode&#123;Val: <span class="number">3</span>, Left: <span class="literal">nil</span>, Right: node9&#125;</span><br><span class="line">node8 := &amp;TreeNode&#123;Val: <span class="number">8</span>, Left: node3, Right: node5&#125;</span><br><span class="line">fmt.Println(sumNumbers(node8))</span><br><span class="line">    <span class="comment">// 输出结果：16875</span></span><br><span class="line">    <span class="comment">// 正确结果：16879</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;leetcode每日一题疑惑&lt;/p&gt;
&lt;p&gt;今天的leetcode每日一题&lt;a href=&quot;https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://zhouyanbo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>惊喜的一天</title>
    <link href="https://zhouyanbo.com/2020/10/27/one-happy-day/"/>
    <id>https://zhouyanbo.com/2020/10/27/one-happy-day/</id>
    <published>2020-10-27T05:57:18.000Z</published>
    <updated>2020-10-27T10:16:17.713Z</updated>
    
    <content type="html"><![CDATA[<p>2020年10月26日，星期一，本是平凡的一天，枯燥的周一，没想到晚上来了点惊喜，十四五年没见的同学突然联系上了。</p><p>初中在离家挺远的安国上学，认识了好多朋友，但是初中毕业以后就回家上学了，好多人慢慢失去了联系，晚上几个常在安国本地的同学聚在一起，想起了我，其中一人留有我的联系方式，还是上大学加上的，给我开了视频，让我一个一个说名字，说实话，好多年了，名字突然叫不上来，但是看着面容都能认出来，还有原来的影子，最大的特点就是全部变胖了。</p><p>有太多的话题，激动的说不出话来，有点想哭的感觉，当时大家在一起玩的很好，关系都不错，只是没有联系了，再联系还是感觉很亲切，大家都喝多了，跟他们视频完脑海中一直浮现十四五年前的画面。</p><p>初中离家远，老师同学都很照顾我，很感激！</p><p>最后约定找时间一定见面好好叙叙旧，太想念大家了，初中的友谊真的深，大部分关系都很好，越往后年龄越大，交心的朋友越来越少了，尤其工作以后，在北京这个快节奏的城市中，大家忙忙碌碌，没有了生活，这一瞬间让人忘记了生活的烦恼，全是对过去美好的回忆，真的很好，无法入眠的一夜。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020年10月26日，星期一，本是平凡的一天，枯燥的周一，没想到晚上来了点惊喜，十四五年没见的同学突然联系上了。&lt;/p&gt;
&lt;p&gt;初中在离家挺远的安国上学，认识了好多朋友，但是初中毕业以后就回家上学了，好多人慢慢失去了联系，晚上几个常在安国本地的同学聚在一起，想起了我，其中
      
    
    </summary>
    
    
      <category term="生活" scheme="https://zhouyanbo.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>leetcode -- 前缀树</title>
    <link href="https://zhouyanbo.com/2020/09/23/trie-prefix-tree/"/>
    <id>https://zhouyanbo.com/2020/09/23/trie-prefix-tree/</id>
    <published>2020-09-23T09:59:25.000Z</published>
    <updated>2020-10-28T06:41:32.457Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode上的一道设计题，要求实现trie这种数据结构，包含插入、查找、前缀查找的操作<br><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></p><p>首先定义Trie struct</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    children []*Trie</span><br><span class="line">    isWord <span class="keyword">bool</span> <span class="comment">//是否为单词 </span></span><br><span class="line">    part <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>children 保存的是当前节点的所有子节点</p><p>isWord 如果当前节点为单词结束，标记为true</p><p>part 记录当前节点的字符，为byte类型</p><h4 id="Insert-插入操作"><a href="#Insert-插入操作" class="headerlink" title="Insert 插入操作"></a>Insert 插入操作</h4><p>遍历要插入的单词word，判断每一个字符是否出现在children中，如果出现了，继续往下遍历，没有出现，则新建一个节点，并且放入当前节点的children中</p><p>结束条件则为遍历的层数跟给定的单词长度一致，并且标记当前节点的isWord属性为true，代表这是一个单词</p><h4 id="Search-查询操作"><a href="#Search-查询操作" class="headerlink" title="Search 查询操作"></a>Search 查询操作</h4><p>同样是遍历所有的children，如果包含当前字符，则继续向下遍历，不包含则结束遍历，返回找不到，当遍历到单词长度的深度的时候，需要判断当前节点的isWord属性是否为true，只有为true的时候才是一个单词，否则返回找不到</p><h4 id="StartsWith-判断以给定的prefix开头"><a href="#StartsWith-判断以给定的prefix开头" class="headerlink" title="StartsWith 判断以给定的prefix开头"></a>StartsWith 判断以给定的prefix开头</h4><p>同search操作相同，只是遍历到最后不需要判断当前节点的isWord属性</p><p>完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    children []*Trie</span><br><span class="line">    isWord <span class="keyword">bool</span> <span class="comment">//是否为单词 </span></span><br><span class="line">    part <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">Trie</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Trie&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">Insert</span><span class="params">(word <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">    this.insert(word, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">insert</span><span class="params">(word <span class="keyword">string</span>, height <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(word) == height &#123;</span><br><span class="line">        this.isWord = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取一个字母查找</span></span><br><span class="line">    w := word[height]</span><br><span class="line">    child := this.matchChild(w)</span><br><span class="line">    <span class="comment">// 不存在新建一个节点加入</span></span><br><span class="line">    <span class="keyword">if</span> child == <span class="literal">nil</span> &#123;</span><br><span class="line">        child = &amp;Trie&#123;part: w&#125;</span><br><span class="line">        this.children = <span class="built_in">append</span>(this.children, child)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继续遍历下一级</span></span><br><span class="line">    child.insert(word, height + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">matchChild</span><span class="params">(w <span class="keyword">byte</span>)</span> *<span class="title">Trie</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, child := <span class="keyword">range</span> this.children &#123;</span><br><span class="line">        <span class="keyword">if</span> child.part == w &#123;</span><br><span class="line">            <span class="keyword">return</span> child</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">Search</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.search(word, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">search</span><span class="params">(word <span class="keyword">string</span>, height <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(word) == height &#123;</span><br><span class="line">        <span class="keyword">if</span> this.isWord &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, child := <span class="keyword">range</span> this.children &#123;</span><br><span class="line">        <span class="keyword">if</span> child.part == word[height] &#123;</span><br><span class="line">            <span class="keyword">return</span> child.search(word, height + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">StartsWith</span><span class="params">(prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.searchStartsWith(prefix, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">searchStartsWith</span><span class="params">(word <span class="keyword">string</span>, height <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(word) == height &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, child := <span class="keyword">range</span> this.children &#123;</span><br><span class="line">        <span class="keyword">if</span> child.part == word[height] &#123;</span><br><span class="line">            <span class="keyword">return</span> child.searchStartsWith(word, height + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Insert(word);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Search(word);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.StartsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode上的一道设计题，要求实现trie这种数据结构，包含插入、查找、前缀查找的操作&lt;br&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-trie-prefix-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/implement-trie-prefix-tree/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先定义Trie struct&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Trie &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    children []*Trie&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    isWord &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//是否为单词 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    part &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://zhouyanbo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>groupcache 源码系列（一）一致性hash算法</title>
    <link href="https://zhouyanbo.com/2020/07/10/groupcache/"/>
    <id>https://zhouyanbo.com/2020/07/10/groupcache/</id>
    <published>2020-07-10T06:35:01.000Z</published>
    <updated>2020-10-28T06:42:25.305Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hash 在此代码中代表函数类型，返回的是无符号32位整数</span></span><br><span class="line"><span class="keyword">type</span> Hash <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">uint32</span></span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    hash     Hash <span class="comment">// 上面的Hash类型</span></span><br><span class="line">    replicas <span class="keyword">int</span>  <span class="comment">// 副本数量，指定一个key 会生成 replicas 个副本，保证hash环的均匀分布</span></span><br><span class="line">    keys     []<span class="keyword">int</span> <span class="comment">// 排序后的key切片</span></span><br><span class="line">    hashMap  <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> <span class="comment">// hashmap 保存每一个hash对应的key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="New方法"><a href="#New方法" class="headerlink" title="New方法"></a>New方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个Map类型的对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(replicas <span class="keyword">int</span>, fn Hash)</span> *<span class="title">Map</span></span> &#123;</span><br><span class="line">    m := &amp;Map&#123;</span><br><span class="line">      replicas: replicas,</span><br><span class="line">      hash:     fn,</span><br><span class="line">      hashMap:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> m.hash == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 不指定Hash方法的时候 默认使用crc32.ChecksumIEEE方法进行hash</span></span><br><span class="line">      m.hash = crc32.ChecksumIEEE</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Add方法"><a href="#Add方法" class="headerlink" title="Add方法"></a>Add方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Add</span><span class="params">(keys ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 遍历添加的所有key</span></span><br><span class="line">    <span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">      <span class="comment">// 对每一个key复制制定的replicas个数 0key 1key 2key ... 对这些key进行hash算法，得到对应的hash值，这些值对应hash环上的一个点，把这些hash值放入keys切片中保存，并且把hash值对应的key保存到hashMap中</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.replicas; i++ &#123;</span><br><span class="line">            hash := <span class="keyword">int</span>(m.hash([]<span class="keyword">byte</span>(strconv.Itoa(i) + key)))</span><br><span class="line">            m.keys = <span class="built_in">append</span>(m.keys, hash)</span><br><span class="line">            m.hashMap[hash] = key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 对keys排序</span></span><br><span class="line">    sort.Ints(m.keys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a>Get方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> m.IsEmpty() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对要查找的key进行hash算法</span></span><br><span class="line">hash := <span class="keyword">int</span>(m.hash([]<span class="keyword">byte</span>(key)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Binary search for appropriate replica.</span></span><br><span class="line">    <span class="comment">// 查找hash后的key在hash环中的位置</span></span><br><span class="line">idx := sort.Search(<span class="built_in">len</span>(m.keys), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> m.keys[i] &gt;= hash &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Means we have cycled back to the first replica.</span></span><br><span class="line"><span class="keyword">if</span> idx == <span class="built_in">len</span>(m.keys) &#123;</span><br><span class="line">idx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回hashMap中对应的index值 m.keys[idx] 是hash值 hashMap[m.keys[idx]] 为hash值对应的key</span></span><br><span class="line"><span class="keyword">return</span> m.hashMap[m.keys[idx]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Hash&quot;&gt;&lt;a href=&quot;#Hash&quot; class=&quot;headerlink&quot; title=&quot;Hash&quot;&gt;&lt;/a&gt;Hash&lt;/h4&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Hash 在此代码中代表函数类型，返回的是无符号32位整数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Hash &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(data []&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;uint32&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://zhouyanbo.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>cache2go 源码解读</title>
    <link href="https://zhouyanbo.com/2020/06/28/cache2go/"/>
    <id>https://zhouyanbo.com/2020/06/28/cache2go/</id>
    <published>2020-06-28T06:31:19.000Z</published>
    <updated>2020-10-28T06:41:54.823Z</updated>
    
    <content type="html"><![CDATA[<p>引用官方的说明</p><blockquote><p>  Concurrency-safe golang caching library with expiration capabilities.</p><p>  是一个并行安全的golang缓存库，带有过期功能</p></blockquote><p>go的开源缓存库，对go新手来说比较简单，看了一遍源码，对其中的源码做下解释记录，方便日后重温</p><p>代码中为了并行安全，在读写操作中都加了锁（除去一些不变的值，例如：CacheItem的key、data、createdOn）</p><a id="more"></a><p>项目目录结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">├── LICENSE.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── benchmark_test.go</span><br><span class="line">├── cache.go</span><br><span class="line">├── cache_test.go</span><br><span class="line">├── cacheitem.go</span><br><span class="line">├── cachetable.go</span><br><span class="line">├── errors.go</span><br><span class="line">└── examples</span><br><span class="line">    ├── callbacks</span><br><span class="line">    │   └── callbacks.go</span><br><span class="line">    ├── dataloader</span><br><span class="line">    │   └── dataloader.go</span><br><span class="line">    └── mycachedapp</span><br><span class="line">        └── mycachedapp.go</span><br></pre></td></tr></table></figure><p>其中主要就三个文件cache.go、cacheitem.go、cachetable.go，其它是一些测试以及example，下面分别对这三个文件做下解释</p><h4 id="cache-go"><a href="#cache-go" class="headerlink" title="cache.go"></a>cache.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    cache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*CacheTable)</span><br><span class="line">    mutex sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cache</span><span class="params">(table <span class="keyword">string</span>)</span> *<span class="title">CacheTable</span></span> &#123;</span><br><span class="line">    mutex.RLock()</span><br><span class="line">    t, ok := cache[table]</span><br><span class="line">    mutex.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      mutex.Lock()</span><br><span class="line">      t, ok = cache[table]</span><br><span class="line">      <span class="comment">// Double check whether the table exists or not.</span></span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        t = &amp;CacheTable&#123;</span><br><span class="line">          name:  table,</span><br><span class="line">          items: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*CacheItem),</span><br><span class="line">        &#125;</span><br><span class="line">        cache[table] = t</span><br><span class="line">      &#125;</span><br><span class="line">      mutex.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cache.go文件比较简单，首先是两个全局变量 ，cache和mutex，cache是个map，其中放的是一个一个的CacheTable对象的指针，Cache方法首先检查cache中是否有指定的table，没有的话创建一个，然后放到cache中，并且返回新加的这个CacheTable对象</p><h4 id="cacheitem-go"><a href="#cacheitem-go" class="headerlink" title="cacheitem.go"></a>cacheitem.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CacheItem <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The item's key.</span></span><br><span class="line">    key <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// The item's data.</span></span><br><span class="line">    data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 过期时间</span></span><br><span class="line">    lifeSpan time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建时间</span></span><br><span class="line">    createdOn time.Time</span><br><span class="line">    <span class="comment">// 上一次被访问时间</span></span><br><span class="line">    accessedOn time.Time</span><br><span class="line">    <span class="comment">// 访问次数计数</span></span><br><span class="line">    accessCount <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// item过期的回调函数，可以有多个</span></span><br><span class="line">    aboutToExpire []<span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含以下方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化CacehItem</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCacheItem</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, lifeSpan time.Duration, data <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">// keepalive item</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">KeepAlive</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">// 返回item的lifeSpan accessedOn createdOn accessCount key data ...这些方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">LifeSpan</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">// 设置过期的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">SetAboutToExpireCallback</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 添加过期回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">AddAboutToExpireCallback</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>cacheitem比较简单，看下注释就可以</p><h4 id="cachetable-go"><a href="#cachetable-go" class="headerlink" title="cachetable.go"></a>cachetable.go</h4><p>CacheTable是管理CacheItem的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CacheTable <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The table's name.</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// 所有的 cached items 都放在items属性中</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*CacheItem</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器，到时见就会自动检查（遍历所有的CacheItem）</span></span><br><span class="line">    cleanupTimer *time.Timer</span><br><span class="line">    <span class="comment">// Current timer duration.</span></span><br><span class="line">    cleanupInterval time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志</span></span><br><span class="line">    logger *log.Logger</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下是一些操作的回调函数</span></span><br><span class="line">    <span class="comment">// Callback method triggered when trying to load a non-existing key.</span></span><br><span class="line">    loadData <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span></span></span><br><span class="line">    <span class="comment">// Callback method triggered when adding a new item to the cache.</span></span><br><span class="line">    addedItem []<span class="function"><span class="keyword">func</span><span class="params">(item *CacheItem)</span></span></span><br><span class="line">    <span class="comment">// Callback method triggered before deleting an item from the cache.</span></span><br><span class="line">    aboutToDeleteItem []<span class="function"><span class="keyword">func</span><span class="params">(item *CacheItem)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含的一些方法看源码中的注释就可以，比较好理解，重点关注下几个方法</p><p>其中有个Add方法，添加一个item，回调用addInternal似有方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">addInternal</span><span class="params">(item *CacheItem)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Careful: do not run this method unless the table-mutex is locked!</span></span><br><span class="line">    <span class="comment">// It will unlock it for the caller before running the callbacks and checks</span></span><br><span class="line">    table.log(<span class="string">"Adding item with key"</span>, item.key, <span class="string">"and lifespan of"</span>, item.lifeSpan, <span class="string">"to table"</span>, table.name)</span><br><span class="line">    table.items[item.key] = item</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache values so we don't keep blocking the mutex.</span></span><br><span class="line">    expDur := table.cleanupInterval</span><br><span class="line">    addedItem := table.addedItem</span><br><span class="line">    table.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否设置了添加item的回调，如果有则执行</span></span><br><span class="line">    <span class="keyword">if</span> addedItem != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> _, callback := <span class="keyword">range</span> addedItem &#123;</span><br><span class="line">        callback(item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we haven't set up any expiration check timer or found a more imminent item.</span></span><br><span class="line">  <span class="comment">// 如果当前cachetable的cleanupInterval为0或者新加入的item的lifeSpan小于cleanupInterval则触发过期检查函数</span></span><br><span class="line">    <span class="keyword">if</span> item.lifeSpan &gt; <span class="number">0</span> &amp;&amp; (expDur == <span class="number">0</span> || item.lifeSpan &lt; expDur) &#123;</span><br><span class="line">      table.expirationCheck()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化cachetable的时候没有设置定时器，在加入第一个item的时候启用定时器，并且在每加入一个item都会触发过期检查去更新定时器</p><p>过期检查是遍历一遍所有数据，找出最先过期的数据，把这个时间当成定时器下次检查的时间（合理设置定时器）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">expirationCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">    table.Lock()</span><br><span class="line">    <span class="keyword">if</span> table.cleanupTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">      table.cleanupTimer.Stop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> table.cleanupInterval &gt; <span class="number">0</span> &#123;</span><br><span class="line">        table.log(<span class="string">"Expiration check triggered after"</span>, table.cleanupInterval, <span class="string">"for table"</span>, table.name)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      table.log(<span class="string">"Expiration check installed for table"</span>, table.name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To be more accurate with timers, we would need to update 'now' on every</span></span><br><span class="line">    <span class="comment">// loop iteration. Not sure it's really efficient though.</span></span><br><span class="line">    now := time.Now()</span><br><span class="line">    smallestDuration := <span class="number">0</span> * time.Second</span><br><span class="line">  <span class="comment">// 遍历table中的所有items，找到最先过期的那一个item</span></span><br><span class="line">    <span class="keyword">for</span> key, item := <span class="keyword">range</span> table.items &#123;</span><br><span class="line">        <span class="comment">// Cache values so we don't keep blocking the mutex.</span></span><br><span class="line">        item.RLock()</span><br><span class="line">        lifeSpan := item.lifeSpan</span><br><span class="line">        accessedOn := item.accessedOn</span><br><span class="line">        item.RUnlock()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// lifeSpan 永不过期</span></span><br><span class="line">        <span class="keyword">if</span> lifeSpan == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> now.Sub(accessedOn) &gt;= lifeSpan &#123; <span class="comment">// 已经过期删除</span></span><br><span class="line">            <span class="comment">// Item has excessed its lifespan.</span></span><br><span class="line">            table.deleteInternal(key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Find the item chronologically closest to its end-of-lifespan.</span></span><br><span class="line">          <span class="comment">// smallestDuration == 0 第一个缓存数据添加进来的时候，把第一个缓存数据的lifeSpan时间做为下次检查时间间隔</span></span><br><span class="line">            <span class="keyword">if</span> smallestDuration == <span class="number">0</span> || lifeSpan-now.Sub(accessedOn) &lt; smallestDuration &#123;</span><br><span class="line">              smallestDuration = lifeSpan - now.Sub(accessedOn)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup the interval for the next cleanup run.</span></span><br><span class="line">    table.cleanupInterval = smallestDuration</span><br><span class="line">    <span class="keyword">if</span> smallestDuration &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// 启动一个goruntine定时器，在smallestDuration之后重新掉用expirationCheck方法检查</span></span><br><span class="line">        table.cleanupTimer = time.AfterFunc(smallestDuration, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">          <span class="keyword">go</span> table.expirationCheck()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    table.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Value方法获取CacheTable中指定的key对应的数据，有则返回，没有执行loadData回调</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*CacheItem, error)</span></span> &#123;</span><br><span class="line">    table.RLock()</span><br><span class="line">    r, ok := table.items[key]</span><br><span class="line">    loadData := table.loadData</span><br><span class="line">    table.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="comment">// Update access counter and timestamp.</span></span><br><span class="line">        r.KeepAlive()</span><br><span class="line">        <span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Item doesn't exist in cache. Try and fetch it with a data-loader.</span></span><br><span class="line">    <span class="keyword">if</span> loadData != <span class="literal">nil</span> &#123;</span><br><span class="line">        item := loadData(key, args...)</span><br><span class="line">        <span class="keyword">if</span> item != <span class="literal">nil</span> &#123;</span><br><span class="line">            table.Add(key, item.lifeSpan, item.data)</span><br><span class="line">            <span class="keyword">return</span> item, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFoundOrLoadable</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码的最后有个MostAccessed方法，该方法返回的是最多被访问的前n个缓存数据，首先定义一个CacheItemPair结构体，该结构体存放每个item的key以及访问次数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CacheItemPair <span class="keyword">struct</span> &#123;</span><br><span class="line">    Key         <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    AccessCount <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再声明了一个切片类型的CacheItemPairList实现了sort接口的三个方法，可以掉用sort.Sort(p)方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CacheItemPairList []CacheItemPair</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p CacheItemPairList)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p CacheItemPairList)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="comment">// 找的是最多被访问的缓存数据，所以 p[i].AccessCount &gt; p[j].AccessCount</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p CacheItemPairList)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i].AccessCount &gt; p[j].AccessCount &#125;</span><br></pre></td></tr></table></figure><p>排序完成后，遍历排序后的数据返回前n个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r []*CacheItem</span><br><span class="line">c := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> p &#123;</span><br><span class="line">   <span class="keyword">if</span> c &gt;= count &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   item, ok := table.items[v.Key]</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      r = <span class="built_in">append</span>(r, item)</span><br><span class="line">   &#125;</span><br><span class="line">   c++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引用官方的说明&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  Concurrency-safe golang caching library with expiration capabilities.&lt;/p&gt;
&lt;p&gt;  是一个并行安全的golang缓存库，带有过期功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;go的开源缓存库，对go新手来说比较简单，看了一遍源码，对其中的源码做下解释记录，方便日后重温&lt;/p&gt;
&lt;p&gt;代码中为了并行安全，在读写操作中都加了锁（除去一些不变的值，例如：CacheItem的key、data、createdOn）&lt;/p&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://zhouyanbo.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>2020年中的思考</title>
    <link href="https://zhouyanbo.com/2020/05/20/start-go/"/>
    <id>https://zhouyanbo.com/2020/05/20/start-go/</id>
    <published>2020-05-20T06:32:35.000Z</published>
    <updated>2020-10-28T06:34:01.832Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="生活" scheme="https://zhouyanbo.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>下半年的一些计划</title>
    <link href="https://zhouyanbo.com/2019/07/15/next-half-year-plan/"/>
    <id>https://zhouyanbo.com/2019/07/15/next-half-year-plan/</id>
    <published>2019-07-15T06:07:48.000Z</published>
    <updated>2020-10-27T06:12:18.469Z</updated>
    
    <content type="html"><![CDATA[<p>越来越觉得自己进步很慢了，几乎停止不前了，大城市的焦虑、生活的琐碎搞的整个人都比较消沉，需要找点事情做，找个感兴趣的事情。</p><p>准备看看数据结构、算法，虽说工作中用不到，但是觉得挺有用的，能理解很多东西，觉得挺有意思，而且现在有很多刷题的网站，能够做出来也会有些喜悦。</p><p>接下来就坚持学习算法，每日做题了，充实！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;越来越觉得自己进步很慢了，几乎停止不前了，大城市的焦虑、生活的琐碎搞的整个人都比较消沉，需要找点事情做，找个感兴趣的事情。&lt;/p&gt;
&lt;p&gt;准备看看数据结构、算法，虽说工作中用不到，但是觉得挺有用的，能理解很多东西，觉得挺有意思，而且现在有很多刷题的网站，能够做出来也会有些喜
      
    
    </summary>
    
    
      <category term="生活" scheme="https://zhouyanbo.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>近况</title>
    <link href="https://zhouyanbo.com/2019/06/20/mid-year-thoughts/"/>
    <id>https://zhouyanbo.com/2019/06/20/mid-year-thoughts/</id>
    <published>2019-06-20T06:04:47.000Z</published>
    <updated>2020-10-27T10:56:31.796Z</updated>
    
    <content type="html"><![CDATA[<p>转眼19年过去了一半了，回想这半年好像也没做啥，时间过的就是这么快。</p><p>想想自己都要三十了，不敢想啊，可怕。</p><p>毕业也5年过去了，有时候总是会回想自己工作的这几年，开始进步还挺大，后来越来越小，有考虑自身的原因，也想过所在环境的问题，都有吧，主要还在于自己，对自己有些认知。</p><p>年龄越大，琐事越来越多，自己不够自信，可能从小没有培养出来，我哥一直安慰我，哈哈哈。</p><p>接下来继续努力，有进步就可以，平平淡淡。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转眼19年过去了一半了，回想这半年好像也没做啥，时间过的就是这么快。&lt;/p&gt;
&lt;p&gt;想想自己都要三十了，不敢想啊，可怕。&lt;/p&gt;
&lt;p&gt;毕业也5年过去了，有时候总是会回想自己工作的这几年，开始进步还挺大，后来越来越小，有考虑自身的原因，也想过所在环境的问题，都有吧，主要还在
      
    
    </summary>
    
    
      <category term="生活" scheme="https://zhouyanbo.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>有趣的乘法</title>
    <link href="https://zhouyanbo.com/2019/01/08/recursive-mulitply/"/>
    <id>https://zhouyanbo.com/2019/01/08/recursive-mulitply/</id>
    <published>2019-01-08T03:14:35.000Z</published>
    <updated>2020-09-09T07:25:20.891Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>leetcode算法思路</p></blockquote><p>leetcode地址：<a href="https://leetcode-cn.com/problems/recursive-mulitply-lcci/" target="_blank" rel="noopener">递归乘法</a> </p><p>该题让用递归的方法求乘法的结果，要求不要用 * 运算符，可以使用加、减、位移</p><p>题目比较简单，把乘法换成加法去做</p><p>解法1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A * B = (A&lt;&lt;1)(b&gt;&gt;1) + A(B%2)</span></span><br><span class="line">        <span class="keyword">if</span> (B == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (B == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> multiply(A, B-<span class="number">1</span>) + A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Users/yanbo/Library/Application Support/typora-user-images/image-20200909112413655.png" alt="image-20200909112413655"></p><p>在题解中看到一种换算成位运算的操作A * B = (A&lt;&lt;1)(b&gt;&gt;1) + A(B%2)，结果内存消耗稍稍少了一点</p><p>解法2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A * B = (A&lt;&lt;1)(b&gt;&gt;1) + A(B%2)</span></span><br><span class="line">        <span class="keyword">if</span> (B == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (B == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (B % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> multiply(A&lt;&lt;<span class="number">1</span>, B&gt;&gt;<span class="number">1</span>) + A;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> multiply(A&lt;&lt;<span class="number">1</span>, B&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Users/yanbo/Library/Application Support/typora-user-images/image-20200909112245826.png" alt="image-20200909112245826"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;leetcode算法思路&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;leetcode地址：&lt;a href=&quot;https://leetcode-cn.com/problems/recursive-mulitply-lcci/&quot; target=&quot;_bl
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://zhouyanbo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>2018 年终总结</title>
    <link href="https://zhouyanbo.com/2018/12/10/2018-summary/"/>
    <id>https://zhouyanbo.com/2018/12/10/2018-summary/</id>
    <published>2018-12-10T08:28:37.000Z</published>
    <updated>2020-09-09T07:25:19.007Z</updated>
    
    <content type="html"><![CDATA[<p>2018就要结束了，总会想起2010年上大学的情景，当时年末还在想明年就是2011年，这个念起来好拗口，一眨眼2018年都要结束了，回顾这一年。。。</p><p>加油吧！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018就要结束了，总会想起2010年上大学的情景，当时年末还在想明年就是2011年，这个念起来好拗口，一眨眼2018年都要结束了，回顾这一年。。。&lt;/p&gt;
&lt;p&gt;加油吧！！！&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="other" scheme="https://zhouyanbo.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自动化</title>
    <link href="https://zhouyanbo.com/2018/11/20/programmer-automation/"/>
    <id>https://zhouyanbo.com/2018/11/20/programmer-automation/</id>
    <published>2018-11-20T08:35:11.000Z</published>
    <updated>2020-09-09T07:26:26.401Z</updated>
    
    <content type="html"><![CDATA[<p>18年是个多病的年，妈妈从年初腿部肿，找了好多医院医生现在吃药也没根治。随着现在电子设备的普及，电脑、手机重度使用者，导致现在眼睛疾病越来越多。先是室友眼睛有问题，寻医问药很多地方，最后拖的时间长了，做了手术恢复中，恢复的挺不错，又是我女朋友突然一天说眼睛不舒服，感觉磨的厉害睁不开眼，赶紧带去医院，最后诊断为干眼症，好在及时发现，医生开了些药需要慢慢调理，是个长期的病，以后用眼都要注意休息了。</p><p>经过这次事情之后，毕竟班还是要上的，医生也不建议丢了工作，平时工作就需要多多注意了，但是毕竟天天面对电脑也很无奈，女朋友在一家知识产权公司做文职工作，在我看来没什么技术含量也没啥提升的空间，尽早离开为好，放在年后考虑了，只是目前有一份每天都要整理邮件的工作，最初几天我去公司帮忙弄了下，去了一次我眼睛都要瞎了，windows电脑，屏幕小，分辨率低，实在是受不了，更别说她现在眼睛还不好，于是到家想了下写个程序能提高一些效率，于是便有了下文的产出。</p><p>首先邮件是outlook导出的.msg后缀的文件，本人电脑Mac Pro无奈打不开这种格式，还花钱买了MailReader软件，后来发现没有必要，分析了下需求准备用python写一个简单的处理脚本，本人平时也不接触python，写的比较垃圾，大家不要在意细节。</p><p>主要记录一下使用的关键package，其它的都是一些细节的需求，没有什么难度，无非是一些字符串的处理，循环，文件处理，最大的问题就是没有办法读取到邮件的主题，千辛万苦最后找到了一个包 <a href="https://github.com/mattgwwalker/msg-extractor" target="_blank" rel="noopener">extract_msg</a> 需要的依赖也比较多，一一安装好就可以，主要用到了它的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg = extract_msg.Message(<span class="string">"path/to/msg/file.msg"</span>, attachmentClass = CustomAttachmentClass)</span><br><span class="line"><span class="comment"># get mail subject</span></span><br><span class="line">subject = msg.subject</span><br></pre></td></tr></table></figure><p>其中是用了python的一个web框架 Django 初次使用，没有深入研究，另外前端页面没有写，本来打算找个前端UI框架的，最后放弃了，没有耽误功夫在前端上，主要实现了功能，后期有时间再补上。</p><p>代码上传到了 <a href="https://github.com/zhouyb-cn/mail-system-tool" target="_blank" rel="noopener">Github</a> </p><p>接下来需要有时间待完成的：</p><ol><li>自动识别邮件主题中的卷号</li><li>做一个漂亮的前端界面</li><li>后续优化</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;18年是个多病的年，妈妈从年初腿部肿，找了好多医院医生现在吃药也没根治。随着现在电子设备的普及，电脑、手机重度使用者，导致现在眼睛疾病越来越多。先是室友眼睛有问题，寻医问药很多地方，最后拖的时间长了，做了手术恢复中，恢复的挺不错，又是我女朋友突然一天说眼睛不舒服，感觉磨的厉
      
    
    </summary>
    
    
      <category term="geek" scheme="https://zhouyanbo.com/tags/geek/"/>
    
  </entry>
  
  <entry>
    <title>生命不息，折腾不止</title>
    <link href="https://zhouyanbo.com/2018/10/10/geek-funny-thing/"/>
    <id>https://zhouyanbo.com/2018/10/10/geek-funny-thing/</id>
    <published>2018-10-10T08:37:56.000Z</published>
    <updated>2020-09-08T07:08:35.310Z</updated>
    
    <content type="html"><![CDATA[<p>最近老大提起了一个说很好玩的聊天客户端<a href="https://weechat.org/" target="_blank" rel="noopener">weechat</a>，说是很Geek，让我研究下给大家做一下分享，下面记录一下过程。</p><p>网上搜索了如何能够在weechat中收发微信消息，最初有点一头雾水，无从下手，只是知道weecaht是一个IRC客户端，官方首页的说明</p><blockquote><p>WeeChat, the extensible chat client.</p></blockquote><blockquote><p>Fast — Light — Free software</p></blockquote><p>轻量级的开源的软件，听说很多大佬在用（大佬都是在用一些看起来很高大上的东西）</p><p>按照<a href="https://weechat.org/files/doc/stable/weechat_user.en.html" target="_blank" rel="noopener">官方文档</a>一步一步来就可以，文档写的很清晰，只是需要花点时间理解weechat是做什么的就可以了，实际上比较简单，weecaht只是一个IRC客户端，IRC客户端也有很多，可以选择其它的客户端，weechat可扩展性比较大，装好weechat之后，又在github上找了一个控制网页微信来收发微信的库，在这里<a href="https://github.com/MaskRay/wechatircd" target="_blank" rel="noopener">https://github.com/MaskRay/wechatircd</a>，按照Readme操作就可以，最后创建一个wechat server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/connect wechat</span><br></pre></td></tr></table></figure><p>即可加载到网页微信端的所有消息，并且可以是现在terminal中收发消息，看起来很高大上，并且可以随时查看以前的消息，都有日志记录，不方便的是对图片、音频、文件收发不太方便，显示到Terminal都是链接形式，</p><p>效果如下：</p><p><img src="/Users/yanbo/Desktop/屏幕快照 2018-12-29 下午4.15.58.png" alt="weechat"></p><hr><p>2018.12.28 补充：</p><p>升级了电脑系统到10.14.2，发现无法显示中文字符，输入中文也无法显示了，都变成了？ 查了资料应该是编码问题，最后升级了iTerm2到最新版本发现解决了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近老大提起了一个说很好玩的聊天客户端&lt;a href=&quot;https://weechat.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;weechat&lt;/a&gt;，说是很Geek，让我研究下给大家做一下分享，下面记录一下过程。&lt;/p&gt;
&lt;p&gt;网上搜索了
      
    
    </summary>
    
    
      <category term="geek" scheme="https://zhouyanbo.com/tags/geek/"/>
    
  </entry>
  
  <entry>
    <title>创意</title>
    <link href="https://zhouyanbo.com/2018/09/10/some-original-ideas/"/>
    <id>https://zhouyanbo.com/2018/09/10/some-original-ideas/</id>
    <published>2018-09-10T08:40:07.000Z</published>
    <updated>2020-09-09T07:27:02.205Z</updated>
    
    <content type="html"><![CDATA[<p>想一些有创意的ideas</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想一些有创意的ideas&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="other" scheme="https://zhouyanbo.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>使用libreoffice转换文档成pdf</title>
    <link href="https://zhouyanbo.com/2018/07/18/libreoffice/"/>
    <id>https://zhouyanbo.com/2018/07/18/libreoffice/</id>
    <published>2018-07-18T09:03:07.000Z</published>
    <updated>2020-09-09T07:25:11.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>将doc、docx、xls、xlsx、ppt、pptx格式的转换成pdf文档</p><h3 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h3><p>系统是centos 7，这里使用libreoffice，在转换过程中发现，只要是文件中包含中文字符，转换之后文件中成了乱码，不可读</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>由于centos 7系统中缺少对中文的支持，需要安装中文字库，参考这里<a href="https://blog.csdn.net/wlwlwlwl015/article/details/51482065" target="_blank" rel="noopener">centos安装中文字库</a>，<br>安装完成后重启libreoffice即可</p><p>附：<a href="https://github.com/lugnsk/pyodconverter" target="_blank" rel="noopener">转换脚本</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;p&gt;将doc、docx、xls、xlsx、ppt、pptx格式的转换成pdf文档&lt;/p&gt;
&lt;h3 id=&quot;实施&quot;&gt;&lt;a href=&quot;#实施&quot; c
      
    
    </summary>
    
    
      <category term="linux" scheme="https://zhouyanbo.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Dropbox 同步问题</title>
    <link href="https://zhouyanbo.com/2018/05/20/dropbox-synchronization/"/>
    <id>https://zhouyanbo.com/2018/05/20/dropbox-synchronization/</id>
    <published>2018-05-20T07:26:12.000Z</published>
    <updated>2020-09-09T07:25:16.300Z</updated>
    
    <content type="html"><![CDATA[<p>最初的时候下载了 <a href="https://dropbox.com/" target="_blank" rel="noopener">Dropbox</a> 做为我重要资料的网盘备份，可是最大的问题就是Dropbox的联网问题，众所周知此工具是被限制的，只能想一些办法FQ才可以使用，后来无奈从电脑上删除了，最近几天在整理<a href="http://1password.com" target="_blank" rel="noopener">1password</a>备份的时候，觉得icloud有点问题（原先使用icloud做备份），而且今年<a href="https://www.icloud.com" target="_blank" rel="noopener">icloud</a>中国由云上贵州运营了，也曝出了一些不好的新闻，不知真假，虽然我也在用icloud的免费5G的空间，反正也没有放什么隐私的材料照片，也就无所谓了，密码这个东西还是需要注意些，比较了一下Dropbox相对安全一些，决定重新捡起Dropbox。</p><p>此站点我是用的<a href="https://welcome.linode.com" target="_blank" rel="noopener">Linode</a>，每个月$5对我来说足够了（没什么浏览量），我在上面部署了ss服务，本地Mac安装ss客户端，添加服务器，选择自动代理模式，由于服务器在日本，延迟200多ms还算可以，基本的Google查询还是可以接受的。</p><p>下载Dropbox，安装在本地，安装好之后发现即使开启了ss还是一直处在连接中的状态，无法连接到服务器，于是在网上找到了方法，首先找到ss的自动模式的PAC文件 gfwlist.js，打来看到其中有一行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="string">"SOCKS5 127.0.0.1:1080; SOCKS 127.0.0.1:1080; DIRECT;"</span>;</span><br></pre></td></tr></table></figure><p>根据每个人的不同配置跟我的不一样，仅供参考，接着打开Dropbox的偏好设置，找到网络 –&gt; 代理服务器，点击更改设置，选择手动，代理服务器类型：SOCKET5，服务器端口号写上就可以了，点击更新，过几秒发现Dropbox可以连接了</p><p>1password在偏好设置中选择同步方式为Dropbox，我只是在Mac跟iphone之间同步，iphone上开启代理即可，经试验，同步还是很快的，可以开心的使用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最初的时候下载了 &lt;a href=&quot;https://dropbox.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dropbox&lt;/a&gt; 做为我重要资料的网盘备份，可是最大的问题就是Dropbox的联网问题，众所周知此工具是被限制的，只能想一些办
      
    
    </summary>
    
    
      <category term="dropbox" scheme="https://zhouyanbo.com/tags/dropbox/"/>
    
  </entry>
  
  <entry>
    <title>image storage server</title>
    <link href="https://zhouyanbo.com/2018/04/10/image-storage-server/"/>
    <id>https://zhouyanbo.com/2018/04/10/image-storage-server/</id>
    <published>2018-04-10T08:44:10.000Z</published>
    <updated>2020-09-09T07:25:13.131Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现个人博客网站很少用到图，存储到一些云服务厂商不知道哪天就给封了，还是放在自己服务器比较安全，决定找时间在现有的<a href="http://img.zhouyanbo.com/" target="_blank" rel="noopener">图片站点</a>加上图片上传功能。</p><h4 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h4><ul><li>图片上传服务</li><li>考虑服务器安全备份问题</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近发现个人博客网站很少用到图，存储到一些云服务厂商不知道哪天就给封了，还是放在自己服务器比较安全，决定找时间在现有的&lt;a href=&quot;http://img.zhouyanbo.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图片站点&lt;/a&gt;加上图
      
    
    </summary>
    
    
      <category term="php" scheme="https://zhouyanbo.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>基本排序算法</title>
    <link href="https://zhouyanbo.com/2018/02/26/sorting-algorithm/"/>
    <id>https://zhouyanbo.com/2018/02/26/sorting-algorithm/</id>
    <published>2018-02-26T03:30:42.000Z</published>
    <updated>2020-09-08T07:08:35.312Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h3><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。<br>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名</p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    length = len(list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, length-i):</span><br><span class="line">            <span class="keyword">if</span> list[j<span class="number">-1</span>] &gt; list[j]:</span><br><span class="line">                list[j<span class="number">-1</span>], list[j] = list[j], list[j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h3 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h3><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。<br>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名</p><h4 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h4><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    length = len(list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, length-i):</span><br><span class="line">            <span class="keyword">if</span> list[j<span class="number">-1</span>] &gt; list[j]:</span><br><span class="line">                list[j<span class="number">-1</span>], list[j] = list[j], list[j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、冒泡排序&quot;&gt;&lt;a href=&quot;#一、冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;一、冒泡排序&quot;&gt;&lt;/a&gt;一、冒泡排序&lt;/h3&gt;&lt;p&gt;冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。&lt;br&gt;它重复地走访过要排序的数
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://zhouyanbo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>升级站点php版本到7.2.1</title>
    <link href="https://zhouyanbo.com/2018/02/01/upgrade-php-to-7/"/>
    <id>https://zhouyanbo.com/2018/02/01/upgrade-php-to-7/</id>
    <published>2018-02-01T07:30:49.000Z</published>
    <updated>2020-09-09T07:27:17.009Z</updated>
    
    <content type="html"><![CDATA[<p>php7已经问世两年多了，都说性能提升了不少，可开发一直在使用php5.6，最近考虑把自己站点的php版本升级一下，目前站点的php版本是5.6.31</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~$ php -v</span><br><span class="line">PHP 5.6.31 (cli) (built: Sep 14 2017 18:12:46)</span><br><span class="line">Copyright (c) 1997-2016 The PHP Group</span><br><span class="line">Zend Engine v2.6.0, Copyright (c) 1998-2016 Zend Technologies</span><br><span class="line">    with Zend OPcache v7.0.6-dev, Copyright (c) 1999-2016, by Zend Technologies</span><br></pre></td></tr></table></figure><p><a href="http://php.net/downloads.php" target="_blank" rel="noopener">php download</a>目前官网的稳定版本是7.2.1，下面记录下升级过程</p><a id="more"></a><p>目前版本5.6.31是通过yum安装的，php7我想通过源码安装</p><ol><li>首先先在本地下载源码包，通过rsync命令上传到服务器某个目录</li><li><p>按照官方文档的安装步骤<a href="http://php.net/manual/zh/install.unix.nginx.php" target="_blank" rel="noopener">php install</a>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxf php-x.x.x</span><br></pre></td></tr></table></figure></li><li><p>配置并构建，参考了<a href="http://blog.51cto.com/jinchuang/1897385" target="_blank" rel="noopener">这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">cd ../php-x.x.x</span><br><span class="line">./configure \</span><br><span class="line">--prefix=/usr/local/php7 \</span><br><span class="line">--with-fpm-user=nginx \</span><br><span class="line">--with-fpm-group=nginx \</span><br><span class="line">--with-bz2 \</span><br><span class="line">--with-curl \</span><br><span class="line">--with-gd \</span><br><span class="line">--with-openssl \</span><br><span class="line">--with-mhash \</span><br><span class="line">--with-jpeg-dir \</span><br><span class="line">--with-png-dir \</span><br><span class="line">--with-freetype-dir \</span><br><span class="line">--with-iconv-dir=/usr/local/libiconv \</span><br><span class="line">--with-gettext \</span><br><span class="line">--with-libxml-dir \</span><br><span class="line">--with-zlib \</span><br><span class="line">--with-xmlrpc \</span><br><span class="line">--with-pcre-regex \</span><br><span class="line">--with-pear \</span><br><span class="line">--with-pdo-mysql=mysqlnd \</span><br><span class="line">--with-mysqli=mysqlnd \</span><br><span class="line">--with-libdir=lib64 \</span><br><span class="line">--enable-dom \</span><br><span class="line">--enable-xml \</span><br><span class="line">--enable-fpm \</span><br><span class="line">--enable-bcmath \</span><br><span class="line">--enable-ftp \</span><br><span class="line">--enable-sockets \</span><br><span class="line">--disable-ipv6 \</span><br><span class="line">--enable-mbregex \</span><br><span class="line">--enable-mbstring \</span><br><span class="line">--enable-calendar \</span><br><span class="line">--enable-static \</span><br><span class="line">--enable-fpm \</span><br><span class="line">--enable-bcmath \</span><br><span class="line">--enable-libxml \</span><br><span class="line">--enable-inline-optimization \</span><br><span class="line">--enable-mbregex \</span><br><span class="line">--enable-opcache \</span><br><span class="line">--enable-pcntl \</span><br><span class="line">--enable-shmop \</span><br><span class="line">--enable-soap \</span><br><span class="line">--enable-sockets \</span><br><span class="line">--enable-sysvsem \</span><br><span class="line">--enable-zip \</span><br><span class="line"></span><br><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure></li><li><p>创建配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cp php.ini-development /usr/local/php7/php.ini</span><br><span class="line">cp /usr/local/php7/etc/php-fpm.conf.default /usr/local/php7/etc/php-fpm.conf</span><br><span class="line">cp /usr/local/php7/etc/php-fpm.d/www.conf.default /usr/local/php7/etc/php-fpm.d/www.conf</span><br><span class="line">// 方法1</span><br><span class="line">cp -R sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm</span><br><span class="line">// 如果没有权限启动</span><br><span class="line">cd /etc/init.d/php-fpm</span><br><span class="line">chmod 755 php-fpm</span><br><span class="line">//启动停止</span><br><span class="line">/etc/init.d/php-fpm start|stop</span><br><span class="line">// 方法2</span><br><span class="line">cp php-7.2.1/sapi/fpm/php-fpm /usr/local/bin/</span><br><span class="line">//启动停止</span><br><span class="line">php-fpm | pkill php-fpm</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ php -v</span><br><span class="line">PHP 7.2.1 (fpm-fcgi) (built: Jan 30 2018 17:06:46)</span><br><span class="line">Copyright (c) 1997-2017 The PHP Group</span><br><span class="line">Zend Engine v3.2.0, Copyright (c) 1998-2017 Zend Technologies</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;php7已经问世两年多了，都说性能提升了不少，可开发一直在使用php5.6，最近考虑把自己站点的php版本升级一下，目前站点的php版本是5.6.31&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;~$ php -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PHP 5.6.31 (cli) (built: Sep 14 2017 18:12:46)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Copyright (c) 1997-2016 The PHP Group&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Zend Engine v2.6.0, Copyright (c) 1998-2016 Zend Technologies&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    with Zend OPcache v7.0.6-dev, Copyright (c) 1999-2016, by Zend Technologies&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;http://php.net/downloads.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;php download&lt;/a&gt;目前官网的稳定版本是7.2.1，下面记录下升级过程&lt;/p&gt;
    
    </summary>
    
    
      <category term="php" scheme="https://zhouyanbo.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>mysql 分页数据重复</title>
    <link href="https://zhouyanbo.com/2018/02/01/mysql-data-duplicate/"/>
    <id>https://zhouyanbo.com/2018/02/01/mysql-data-duplicate/</id>
    <published>2018-02-01T07:17:34.000Z</published>
    <updated>2020-09-08T07:08:35.311Z</updated>
    
    <content type="html"><![CDATA[<p><strong>BUG mysql分页数据偶尔有重复</strong></p><p>解决：在sql语句中使用了order by field，其中filed字段非id，数据有重复导致分页数据偶尔会重复，再增加order by id可以解决，参考<a href="https://stackoverflow.com/questions/43798247/laravel-pagination-showing-duplicate-and-replacing-random-row" target="_blank" rel="noopener">stackoverflow</a><br>以及 <a href="https://stackoverflow.com/questions/6662837/how-mysql-order-the-rows-with-same-values" target="_blank" rel="noopener">stackoverflow</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;BUG mysql分页数据偶尔有重复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决：在sql语句中使用了order by field，其中filed字段非id，数据有重复导致分页数据偶尔会重复，再增加order by id可以解决，参考&lt;a href=&quot;https:
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://zhouyanbo.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>php 502</title>
    <link href="https://zhouyanbo.com/2018/01/25/php-502-bad-gatewway/"/>
    <id>https://zhouyanbo.com/2018/01/25/php-502-bad-gatewway/</id>
    <published>2018-01-25T05:33:20.000Z</published>
    <updated>2020-09-09T07:25:49.154Z</updated>
    
    <content type="html"><![CDATA[<p><strong>记录一次bug查找经历</strong></p><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>偶然间打开一个以前的项目，浏览器显示 502 Bad Gateway，最开始以为php-fpm没有启动，后来发现不是这个原因</p><h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><ol><li>nginx、php-fpm都服务正常</li><li>配置无误，访问root目录下的html文件都能正常访问，php文件都是502，定位到php-fpm出问题</li><li><p>查看nginx错误日志，报错信息(我电脑php-fpm监听的9011端口)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[error] 16914#16914: *1314340 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: ****, server: ****, request: &quot;GET **** HTTP/1.1&quot;, upstream: &quot;fastcgi://127.0.0.1:9011&quot;, host: &quot;zhouyanbo.com&quot;</span><br></pre></td></tr></table></figure></li><li><p>检查php-fpm.log文件(一般位置在/var/log/php-fpm/error.log)，没有错误信息，修改/etc/php-fpm.d/<a href="http://www.conf配置" target="_blank" rel="noopener">www.conf配置</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch_workers_output = yes</span><br></pre></td></tr></table></figure></li><li><p>重新请求查看php-fpm.log日志，报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[pool www] child 31776 said into stderr: &quot;ERROR: Connection disallowed: IP address &apos;127.0.0.1&apos; has been dropped.&quot;</span><br></pre></td></tr></table></figure></li><li><p>最后修改/etc/php-fpm.d/<a href="http://www.conf配置，原来是any改为127.0.0.1" target="_blank" rel="noopener">www.conf配置，原来是any改为127.0.0.1</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen.allowed_clients = 127.0.0.1</span><br></pre></td></tr></table></figure></li><li><p>重启能正常访问</p></li></ol><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>按道理说listen.allowed_clients = any也是能正常访问的，any包括了所有，但是莫名其妙会出现502的问题，暂时修改为127.0.0.1能正常访问了，以后有时间再研究下，先做下记录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;记录一次bug查找经历&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;p&gt;偶然间打开一个以前的项目，浏览器显示 502 Bad Gateway
      
    
    </summary>
    
    
      <category term="php" scheme="https://zhouyanbo.com/tags/php/"/>
    
  </entry>
  
</feed>
